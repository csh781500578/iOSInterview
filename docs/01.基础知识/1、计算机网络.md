#### 计算机基础
##### 1. TCP的三次握手过程？
![001.jpg](/Users/admin/Code/study/iOSInterview/res/001.jpg)
所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。

三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。

+ 第一次握手(SYN=1, seq=x):客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。发送完毕后，客户端进入 SYN_SEND 状态。

+ 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。

+ 第三次握手(ACK=1，ACKnum=y+1)：客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1。发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。

##### 2. TCP的四次挥手过程？
TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。

+ 第一次挥手(FIN=1，seq=x)：假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。发送完毕后，客户端进入 FIN_WAIT_1 状态。

+ 第二次挥手(ACK=1，ACKnum=x+1)：服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。

+ 第三次挥手(FIN=1，seq=y)：服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。

+ 第四次挥手(ACK=1，ACKnum=y+1)：客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。

##### 3. 为什么进行三次握手
+ 在谢希仁著《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。在另一部经典的《计算机网络》一书中讲“三次握手”的目的是为了解决“网络中存在延迟的重复分组”的问题。

在谢希仁著《计算机网络》书中同时举了一个例子，如下：
+ “已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”

##### 4. 为什么进行四次挥手
+ 那四次分手又是为何呢？TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。

##### 5. HTTPS的握手过程
+ 1.浏览器将自己支持的一套加密规则发送给网站。
+ 2.网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。
+ 3.浏览器获得网站证书之后浏览器要做以下工作：
	+ 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。
	+ 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。
	+ 使用约定好的HASH算法计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。
+  4.网站接收浏览器发来的数据之后要做以下的操作：
	+ 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。
	+ 使用密码加密一段握手消息，发送给浏览器。
+  5.浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。

![002.jpg](/Users/admin/Code/study/iOSInterview/res/002.jpg)

##### 5. 什么是中间人攻击？怎么预防？
+ 中间人把自己的公钥给到客户端，之后用自己的私钥解开客户端数据，再用后台的公钥加密数据，发给后台。这样中间人能拿到双端的数据。 一般禁止接入代理和在代码内比对证书。

##### 6. charles抓包过程？
+ 运行charles，手机配置代理。如果是http协议，charles能看到所有的请求和返回数据。如果要看到https的数据，需要在手机上安装charles证书，并信任证书。

##### 7.TCP和UDP的区别
+ TCP是IP网络上面向连接的流，保证所有发送的包能够按照正确的顺序到达目的地。这意味着发送端要接受ACK包，包自动重传，相对于UDP来说会引起额外延迟以及传输效率更低。TCP还有拥塞控制，流量控制，错误校验等其他机制。

+ UDP是无连接传输协议，面向数据报传输，只保证单个数据报的正确性。数据报到达目的地，有可能会乱序，丢包，或者根本到达不了。由于它没有ACK，所以它比TCP传输效率更高。一般用在实时通讯，相对于TCP连接的开销，虽然存在较小丢包率，但更加适合。

+ 在某些场合下,UDP用来广播包传输。这在例如DHCP协议有时候是最基本的，因为客户端并没有接收到IP地址(DHCP 协商协议目的)，这时候是没有办法在没有IP地址的情况下建立起TCP连接的。

##### 8.TCP拥塞控制
+ 慢启动、当 CongWin低于Threshold, 发送端在慢启动阶段，窗口指数增长。
+ 加性增、当 CongWin高于Threshold, 发送端在拥塞避免阶段，窗口线性增长。
+ 乘性减、当接收到三个重复的ACK，Threshold设置为CongWin/2，CongWin设置为Threshold。
+ 重置、当超时发生的时候，Threshold设置为CongWin/2，CongWin设置为1MSS，重新跑1-3流程。



![003.png](/Users/admin/Code/study/iOSInterview/res/003.png)
