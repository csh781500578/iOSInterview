### oc的指针是什么
```
MyClass *obj = [[MyClass alloc]init];  
NSLog(@"obj:%p", obj);  
NSLog(@"&obj:%p", &obj);  
```
obj是一个指针变量，它指向obj对象的地址。&obj指的是obj这个指针变量所在的地址。


### objc中向一个nil对象发送消息将会发生什么
+ 在Objective-C中向nil发送消息完全有效，但是不会有任何作用
+ 如果方法返回值是一个对象，那么发送给nil的消息将返回0（nil）
+ 向nil对象发送消息，在寻找对象的isa指针时就是0地址返回了

### objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？
+ 在objc动态编译时，每个人方法在运行时都会被动态的转为消息发送。即[obj foo]会被转为objc_msgSend(obj,@selector(foo));

### 什么时候会上报unrecognized selector的异常？
当调用该对象上某个方法，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果在最顶层的父类中依然找不到对应的方法时，程序在运行时会崩溃并抛出unrecognized selector的异常。



### 下面的代码输出什么？
```
@implementation Son : Father
- (id)init
{
	self = [super init];
    if (self) {
    	NSLog(@"%@", NSStringFromClass([self class]));
        NSLog(@"%@",NSStringFromclass([super class]))
    }
    return self;
}
@end

```
答案：都输出Son

+ self是类的隐藏参数，指向当前调用对象方法的实例。
+ 而super是一个编译器标识符，和self指向同一个消息接受者。
+ self和super的不同点在于，super会告诉编译器，调用这个方法时，要从父类的方法，而不是在本类里查找。

### objc中的类方法和实例方法有什么本质区别和联系？
+ 类方法
	1. 类方法是属于类对象的
	2. 类方法只能通过类对象调用
	3. 类方法中的self是类对象
	4. 类方法可以调用其他的类方法
	5. 类方法中不能访问成员变量
	6. 类方法中不能直接调用对象方法
+ 实例方法
	1. 实例方法是属于实例对象的
	2. 实例方法只能通过实例对象调用
	3. 实例方法中的self是实例对象
	4. 实例方法中可以访问成员变量
	5. 实例方法中直接调用实例方法
	6. 实例方法中也可以调用类方法（通过类名）方法 

### UIView/CALayer

### AutoLayout

### imageName/imageWithContentsOfFile/imageWithData

### 参考资料
+ https://blog.csdn.net/MinggeQingchun/article/details/72625129


